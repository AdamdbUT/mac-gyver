// my_ep1.c /// j'y fais ce que je veux ! Na !
// OUT buffer (pc vers pic)


#include "my_ep1.h"
#include "my_ep2.h"
#include "my_usb.h"
#include <pic18fregs.h>
#include "toto.h"
#include "common_types.h"
#include <boot_iface.h>
#include "servos.h"
#include "analogs.h"

#include "../../../My_usb/src/commandes.h"

volatile uchar __at(0x500) ep1_OutBuffer[MY_EP1_BUFFER_SIZE];

uchar mydata[64];

void my_ep1_init(void)
{
    EP_OUT_BD(1).Cnt = MY_EP1_BUFFER_SIZE;
    EP_OUT_BD(1).ADR = (uchar __data *)&ep1_OutBuffer;
    EP_OUT_BD(1).Stat.uc = BDS_USIE | BDS_DAT0 | BDS_DTSEN;
    UEP1 = EPHSHK_EN | EPOUTEN_EN | EPCONDIS_EN;       // Init EP1 as an OUT EP
}

void my_ep1_out(void)
{
    if(EP_OUT_BD(1).Cnt >= 1)
    {
        switch(ep1_OutBuffer[0])
        {
            case GET_ANALOGS :
                ep2_num_bytes_to_send = 2 * NB_ANALOGS + 1;
		send_an[0] = ANALOGS_OK;
		ep2_source_data = send_an;
		my_prepare_ep2_in();
		break;
	    case GET_DIGITALS :
                ep2_num_bytes_to_send = 2;
                mydata[0] = DIGITALS_OK;
                mydata[1] = PORTB && 0xEF;
		ep2_source_data = mydata;
		my_prepare_ep2_in();
		break;
	    case SET_POS_SERVO :
		if(set_servo(ep1_OutBuffer[1], *(int*)(&ep1_OutBuffer[2])))
		    mydata[0] = SERVO_OK;
		else 
	 	    mydata[0] = SERVO_ID_OUT_OF_RANGE;
                ep2_num_bytes_to_send = 1;
		ep2_source_data = mydata;
		my_prepare_ep2_in();
		break;
	    case SET_POS_MOTEUR :
                switch(ep1_OutBuffer[1])
		{
		    case MOT_HAUT_BAS :
			unsigned char pos = ep1_OutBuffer[2];
			break;
		    case MOT_AV_ARR :
			unsigned char pos = ep1_OutBuffer[2];
                        break;
		    default : break;
		}
		break;
	    case UPDATE :
		ep2_num_bytes_to_send = update(mydata, sizeof(mydata));
		ep2_source_data = mydata;
		my_prepare_ep2_in();
		break;
            default:
                // Raise an error
                EP_OUT_BD(1).Cnt = MY_EP1_BUFFER_SIZE;
                EP_OUT_BD(1).ADR = (uchar __data *)&ep1_OutBuffer;
                EP_OUT_BD(1).Stat.uc = BDS_USIE | BDS_BSTALL;
                break;
        }
        EP_OUT_BD(1).Cnt = MY_EP1_BUFFER_SIZE;
        if(EP_OUT_BD(1).Stat.DTS == 0)
        {
            EP_OUT_BD(1).Stat.uc = BDS_USIE | BDS_DAT1 | BDS_DTSEN;
        }
        else
        {
            EP_OUT_BD(1).Stat.uc = BDS_USIE | BDS_DAT0 | BDS_DTSEN;
        }
    }
    else // Raise an error
    {
        EP_OUT_BD(1).Cnt = MY_EP1_BUFFER_SIZE;
        EP_OUT_BD(1).ADR = (uchar __data *)&ep1_OutBuffer;
        EP_OUT_BD(1).Stat.uc = BDS_USIE | BDS_BSTALL;
    }
}


